# Assignment 2 — Minimum Spanning Tree Using Prim’s Algorithm

## Title  
Implementing Prim’s Algorithm Using Adjacency List Representation

## Objective  
To write a program that accepts a weighted graph from the user, represents it using an **adjacency list**, and applies **Prim’s Algorithm** to generate the **Minimum Spanning Tree (MST)**.

## Theory  
A Minimum Spanning Tree (MST) of a connected weighted graph is a set of edges that:

- Connects all vertices  
- Contains no cycles  
- Has the minimum possible total edge weight  

### Prim’s Algorithm  
Prim’s Algorithm grows the MST one vertex at a time.  
It always selects the **minimum-weight edge** that connects a visited vertex to an unvisited one.

### Adjacency List Representation  
An adjacency list represents each vertex as a list of pairs:  
`(neighbor, weight)`  
It is memory-efficient and ideal for sparse graphs.

## Algorithm  

### 1. Build Adjacency List  
1. Input number of vertices  
2. Input number of edges  
3. For each edge (u, v, w):  
   - Add `(v, w)` to adjacency list of `u`  
   - Add `(u, w)` to adjacency list of `v`

### 2. Prim’s Algorithm  
1. Mark all vertices unvisited  
2. Pick a starting vertex (0)  
3. Push `(0, 0)` into priority queue  
4. While PQ not empty:  
   - Extract minimum-weight edge  
   - If vertex already visited → skip  
   - Mark vertex visited  
   - Add its weight to MST cost  
   - Push all adjacent unvisited vertices to PQ  
5. Continue until all vertices are visited

---

## Code (C++)

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

typedef pair<int, int> P; 
// (weight, vertex)

int main() {
    int n, e;
    cout << "Enter number of vertices: ";
    cin >> n;

    cout << "Enter number of edges: ";
    cin >> e;

    vector<pair<int, int>> adj[20]; // adjacency list

    cout << "Enter edges (u v w):\n";
    for (int i = 0; i < e; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        adj[u].push_back({v, w});
        adj[v].push_back({u, w}); // undirected
    }

    vector<bool> visited(n, false);
    priority_queue<P, vector<P>, greater<P>> pq;

    pq.push({0, 0}); // (weight, vertex)
    int mst_cost = 0;

    cout << "\nEdges in MST:\n";

    while (!pq.empty()) {
        auto [wt, u] = pq.top();
        pq.pop();

        if (visited[u])
            continue;

        visited[u] = true;
        mst_cost += wt;

        if (wt != 0)
            cout << "Selected edge weight: " << wt << "\n";

        for (auto &edge : adj[u]) {
            int v = edge.first;
            int w = edge.second;
            if (!visited[v]) {
                pq.push({w, v});
            }
        }
    }

    cout << "\nTotal cost of MST: " << mst_cost << endl;

    return 0;
}
```

---

## Sample Output (Text Format)

```
Enter number of vertices: 5
Enter number of edges: 6
Enter edges (u v w):
0 1 2
0 3 6
1 2 3
1 3 8
1 4 5
2 4 7

Edges in MST:
Selected edge weight: 2
Selected edge weight: 3
Selected edge weight: 5
Selected edge weight: 7

Total cost of MST: 17
```
