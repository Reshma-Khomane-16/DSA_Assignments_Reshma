# Assignment 3 — Minimum Spanning Tree Using Kruskal’s Algorithm (Student Generated)

## Title  
Implementing Kruskal’s Algorithm Using Adjacency List Representation

## Objective  
To write a program that accepts a weighted graph from the user, represents it using an **adjacency list**, and applies **Kruskal’s Algorithm** to generate the **Minimum Spanning Tree (MST)**.

## Theory  
A Minimum Spanning Tree (MST) of a connected weighted graph is a set of edges that:

- Connects all vertices  
- Contains no cycles  
- Has the minimum possible total edge weight  

### Kruskal’s Algorithm  
Kruskal’s Algorithm builds the MST by always selecting the **globally minimum-weight edge** that connects two **different components**.  
It uses **Disjoint Set / Union–Find** to detect cycles efficiently.

### Adjacency List Representation  
Each vertex stores a list of pairs:  
`(neighbor, weight)`  
Used only for graph input.  
Kruskal processes **all edges as a list** sorted by weight.

## Algorithm  

### 1. Build Adjacency List  
1. Input number of vertices  
2. Input number of edges  
3. For each edge (u, v, w):  
   - Add `(v, w)` to adjacency list of `u`  
   - Add `(u, w)` to adjacency list of `v`  
4. Store all edges separately for sorting

### 2. Kruskal’s Algorithm  
1. Sort all edges by weight (ascending)  
2. Create **Disjoint Set** for all vertices  
3. For each edge (u, v, w):  
   - If `FIND(u) != FIND(v)` (no cycle)  
       - Add edge to MST  
       - UNION(u, v)  
4. Continue until MST contains **n – 1 edges**

---

## Code (C++)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Edge {
    int u, v, w;
};

struct Subset {
    int parent;
    int rank;
};

int findParent(vector<Subset>& subsets, int x) {
    if (subsets[x].parent != x)
        subsets[x].parent = findParent(subsets, subsets[x].parent);
    return subsets[x].parent;
}

void unionSet(vector<Subset>& subsets, int x, int y) {
    int rootX = findParent(subsets, x);
    int rootY = findParent(subsets, y);

    if (rootX != rootY) {
        if (subsets[rootX].rank < subsets[rootY].rank)
            subsets[rootX].parent = rootY;
        else if (subsets[rootX].rank > subsets[rootY].rank)
            subsets[rootY].parent = rootX;
        else {
            subsets[rootY].parent = rootX;
            subsets[rootX].rank++;
        }
    }
}

int main() {
    int n, e;
    cout << "Enter number of vertices: ";
    cin >> n;

    cout << "Enter number of edges: ";
    cin >> e;

    vector<pair<int, int>> adj[20];
    vector<Edge> edges;

    cout << "Enter edges (u v w):\n";
    for (int i = 0; i < e; i++) {
        int u, v, w;
        cin >> u >> v >> w;

        adj[u].push_back({v, w});
        adj[v].push_back({u, w});

        edges.push_back({u, v, w});
    }

    sort(edges.begin(), edges.end(),
        [](Edge a, Edge b) { return a.w < b.w; });

    vector<Subset> subsets(n);
    for (int i = 0; i < n; i++) {
        subsets[i].parent = i;
        subsets[i].rank = 0;
    }

    vector<Edge> mst;
    int mst_cost = 0;

    cout << "\nEdges in MST:\n";

    for (auto &edge : edges) {
        int u = edge.u;
        int v = edge.v;
        int w = edge.w;

        int parentU = findParent(subsets, u);
        int parentV = findParent(subsets, v);

        if (parentU != parentV) {
            mst.push_back(edge);
            mst_cost += w;
            cout << u << " -- " << v << "  weight: " << w << "\n";
            unionSet(subsets, parentU, parentV);
        }
    }

    cout << "\nTotal cost of MST: " << mst_cost << endl;

    return 0;
}


##sample output:
Enter number of vertices: 5
Enter number of edges: 6
Enter edges (u v w):
0 1 2
0 3 6
1 2 3
1 3 8
1 4 5
2 4 7

Edges in MST:
0 -- 1  weight: 2
1 -- 2  weight: 3
1 -- 4  weight: 5
0 -- 3  weight: 6

Total cost of MST: 16
