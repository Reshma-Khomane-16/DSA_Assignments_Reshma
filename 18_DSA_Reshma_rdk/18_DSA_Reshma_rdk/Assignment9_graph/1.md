# Assignment 1 â€” Graph Representation Using Adjacency Matrix & Traversals (Student Generated)

## Title  
Graph Representation Using Adjacency Matrix and Performing BFS & DFS Traversals

## Objective  
To write a program that accepts a graph from the user, represents it using an **adjacency matrix**, and performs **Breadth-First Search (BFS)** and **Depth-First Search (DFS)** traversals.

## Theory  
A graph is a collection of vertices connected by edges. It can be represented using multiple methods, but the **adjacency matrix** is the simplest:

- An **adjacency matrix** is a 2D array where  
  `matrix[i][j] = 1` if there is an edge between vertex *i* and *j*; otherwise `0`.

### Traversals  
- **DFS (Depth-First Search):**  
  Explores as far as possible along a branch before backtracking. Typically uses recursion or a stack.

- **BFS (Breadth-First Search):**  
  Explores all neighbors level-by-level using a queue.

These traversals are used for pathfinding, connectivity checking, and graph exploration.

## Algorithm  

### 1. Create Adjacency Matrix  
1. Accept number of vertices  
2. Accept number of edges  
3. For each edge (u, v):  
   - matrix[u][v] = 1  
   - matrix[v][u] = 1 (for undirected graph)

### 2. DFS Traversal  
1. Mark all vertices unvisited  
2. Start from a given vertex  
3. Visit vertex, mark it visited  
4. Recursively visit all unvisited neighbors

### 3. BFS Traversal  
1. Mark all vertices unvisited  
2. Start from a given vertex and push to queue  
3. While queue not empty:  
   - Pop vertex  
   - Visit and mark it  
   - Push all unvisited neighbors to queue

---

## Code (C++)

```cpp
#include <iostream>
#include <queue>
using namespace std;

void DFS(int v, int visited[], int adj[20][20], int n) {
    cout << v << " ";
    visited[v] = 1;

    for (int i = 0; i < n; i++) {
        if (adj[v][i] == 1 && visited[i] == 0) {
            DFS(i, visited, adj, n);
        }
    }
}

void BFS(int start, int adj[20][20], int n) {
    int visited[20] = {0};
    queue<int> q;

    q.push(start);
    visited[start] = 1;

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        cout << v << " ";

        for (int i = 0; i < n; i++) {
            if (adj[v][i] == 1 && visited[i] == 0) {
                q.push(i);
                visited[i] = 1;
            }
        }
    }
}

int main() {
    int n, e;
    int adj[20][20] = {0};

    cout << "Enter number of vertices: ";
    cin >> n;

    cout << "Enter number of edges: ";
    cin >> e;

    cout << "Enter edges (u v): \n";
    for (int i = 0; i < e; i++) {
        int u, v;
        cin >> u >> v;
        adj[u][v] = 1;
        adj[v][u] = 1; // Undirected graph
    }

    cout << "\nAdjacency Matrix:\n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << adj[i][j] << " ";
        }
        cout << endl;
    }

    int visited[20] = {0};

    cout << "\nDFS Traversal starting from 0: ";
    DFS(0, visited, adj, n);

    cout << "\nBFS Traversal starting from 0: ";
    BFS(0, adj, n);

    return 0;
}
```

---

## Sample Output (Text Format)

```
Enter number of vertices: 5
Enter number of edges: 6
Enter edges (u v):
0 1
0 2
1 3
1 4
2 4
3 4

Adjacency Matrix:
0 1 1 0 0
1 0 0 1 1
1 0 0 0 1
0 1 0 0 1
0 1 1 1 0

DFS Traversal starting from 0: 0 1 3 4 2
BFS Traversal starting from 0: 0 1 2 3 4
```
