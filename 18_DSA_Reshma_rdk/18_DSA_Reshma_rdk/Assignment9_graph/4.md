# Assignment 4 â€” Shortest Path Using Dijkstraâ€™s Algorithm 

## Title 
Implementing Dijkstra's Algorithm Using Adjacency List Representation

---

## Objective 
To write a program that accepts a **weighted graph** from the user, represents it using an **adjacency list**, and applies **Dijkstraâ€™s Algorithm** to find the **shortest distance** from a source node to all other nodes, and specifically to a target node.

---

## Theory 
Dijkstra's algorithm is a **greedy algorithm** used to find the shortest path between nodes in a graph, provided all edge weights are **non-negative**.

### Dijkstraâ€™s Algorithm 
The algorithm maintains a set of vertices whose **shortest distance** from the source has been definitively calculated. It repeatedly selects the unvisited vertex with the minimum distance and updates the distances of its neighbors through a process called **relaxation**.

* **Relaxation:** The core step where we check if we can improve the shortest distance to a neighbor $v$ by going through the current vertex $u$. The distance to $v$ is updated if:
    $$\text{dist}[u] + \text{weight}(u, v) < \text{dist}[v]$$

### Adjacency List Representation 
An adjacency list represents each vertex as a list of pairs:
` (neighbor, weight) `
This representation is memory-efficient and is commonly used with Dijkstraâ€™s algorithm, typically implemented using a **Min-Priority Queue**.



---

## Algorithm 

### 1. Build Adjacency List 
1.  Input the number of vertices ($V$) and edges ($E$).
2.  Input a specified **source** node and **destination** node.
3.  For each edge $(u, v, w)$ (where $w$ is the weight):
    * Add `(v, w)` to the adjacency list of $u$. (For an undirected graph, also add `(u, w)` to $v$'s list).

### 2. Dijkstraâ€™s Algorithm 
1.  Initialize a distance array $\text{dist}[]$ of size $V$ with $\infty$, and a $\text{visited}[]$ array with $\text{false}$.
2.  Set $\text{dist}[\text{source}] = 0$.
3.  Create a **Min-Priority Queue (PQ)** and push the pair `(0, source)` (distance, vertex).
4.  While PQ is not empty:
    * Extract the pair `(d, u)` with the **minimum distance** $d$ from the PQ.
    * If $d > \text{dist}[u]$ (outdated entry) $\rightarrow$ skip.
    * For each neighbor $v$ of $u$ with edge weight $w$:
        * **Relaxation:** If $\text{dist}[u] + w < \text{dist}[v]$:
            * Update $\text{dist}[v] = \text{dist}[u] + w$.
            * Push the new pair $(\text{dist}[v], v)$ into the PQ.
5.  After the loop, $\text{dist}[\text{destination}]$ holds the shortest distance.

---

## Code (C++)

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
using namespace std;

typedef pair<int, int> P; 
// The priority queue will store: (distance, vertex)

const int INF = numeric_limits<int>::max();

void dijkstra(int n, const vector<pair<int, int>> adj[], int source, int dest) {
    // 1. Initialization
    vector<int> dist(n, INF);
    // Min-Priority Queue: (distance, vertex). 'greater<P>' ensures min-heap.
    priority_queue<P, vector<P>, greater<P>> pq;

    dist[source] = 0;
    pq.push({0, source});

    // 2. Main Algorithm Loop
    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        // If a shorter path to u was found and processed earlier, skip this outdated entry
        if (d > dist[u]) {
            continue;
        }

        // Optimization: Stop if we've reached the destination
        if (u == dest) {
            break;
        }

        // Relaxation step for all neighbors
        for (const auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;

            // Check if going through u provides a shorter path to v
            // Also check for potential overflow (dist[u] != INF)
            if (dist[u] != INF && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }

    // 3. Output Result
    if (dist[dest] == INF) {
        cout << "\nNode " << dest << " is unreachable from node " << source << ".\n";
    } else {
        cout << "\nShortest distance from node " << source << " to node " << dest << " is: " << dist[dest] << endl;
    }
}

int main() {
    int n, e;
    cout << "Enter number of vertices: ";
    cin >> n;

    cout << "Enter number of edges: ";
    cin >> e;

    // Adjacency list: adj[u] stores list of {v, w}
    // Note: Array size [20] is fixed. For robust code, use vector<vector<P>> adj(n);
    vector<pair<int, int>> adj[20]; 

    cout << "Enter edges (u v w):\n";
    for (int i = 0; i < e; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        // Assuming a directed graph. For undirected, add the reverse edge.
        adj[u].push_back({v, w});
        // For undirected, uncomment the line below:
        // adj[v].push_back({u, w}); 
    }

    int source, dest;
    cout << "\nEnter source node: ";
    cin >> source;
    cout << "Enter destination node: ";
    cin >> dest;

    if (source < 0 || source >= n || dest < 0 || dest >= n) {
        cout << "Invalid source or destination node.\n";
        return 1;
    }

    dijkstra(n, adj, source, dest);

    return 0;
}
Here is the complete, single Markdown file text for your Assignment 4, integrating all the provided sections into one cohesive document.

Markdown

# Assignment 4 â€” Shortest Path Using Dijkstraâ€™s Algorithm (Student Generated)

## Title ðŸ—ºï¸
Implementing Dijkstra's Algorithm Using Adjacency List Representation

---

## Objective 
To write a program that accepts a **weighted graph** from the user, represents it using an **adjacency list**, and applies **Dijkstraâ€™s Algorithm** to find the **shortest distance** from a source node to all other nodes, and specifically to a target node.

---

## Theory 
Dijkstra's algorithm is a **greedy algorithm** used to find the shortest path between nodes in a graph, provided all edge weights are **non-negative**.

### Dijkstraâ€™s Algorithm 
The algorithm maintains a set of vertices whose **shortest distance** from the source has been definitively calculated. It repeatedly selects the unvisited vertex with the minimum distance and updates the distances of its neighbors through a process called **relaxation**.

* **Relaxation:** The core step where we check if we can improve the shortest distance to a neighbor $v$ by going through the current vertex $u$. The distance to $v$ is updated if:
    $$\text{dist}[u] + \text{weight}(u, v) < \text{dist}[v]$$

### Adjacency List Representation 
An adjacency list represents each vertex as a list of pairs:
` (neighbor, weight) `
This representation is memory-efficient and is commonly used with Dijkstraâ€™s algorithm, typically implemented using a **Min-Priority Queue**.



---

## Algorithm 

### 1. Build Adjacency List 
1.  Input the number of vertices ($V$) and edges ($E$).
2.  Input a specified **source** node and **destination** node.
3.  For each edge $(u, v, w)$ (where $w$ is the weight):
    * Add `(v, w)` to the adjacency list of $u$. (For an undirected graph, also add `(u, w)` to $v$'s list).

### 2. Dijkstraâ€™s Algorithm 
1.  Initialize a distance array $\text{dist}[]$ of size $V$ with $\infty$, and a $\text{visited}[]$ array with $\text{false}$.
2.  Set $\text{dist}[\text{source}] = 0$.
3.  Create a **Min-Priority Queue (PQ)** and push the pair `(0, source)` (distance, vertex).
4.  While PQ is not empty:
    * Extract the pair `(d, u)` with the **minimum distance** $d$ from the PQ.
    * If $d > \text{dist}[u]$ (outdated entry) $\rightarrow$ skip.
    * For each neighbor $v$ of $u$ with edge weight $w$:
        * **Relaxation:** If $\text{dist}[u] + w < \text{dist}[v]$:
            * Update $\text{dist}[v] = \text{dist}[u] + w$.
            * Push the new pair $(\text{dist}[v], v)$ into the PQ.
5.  After the loop, $\text{dist}[\text{destination}]$ holds the shortest distance.

---

## Code (C++)

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
using namespace std;

typedef pair<int, int> P; 
// The priority queue will store: (distance, vertex)

const int INF = numeric_limits<int>::max();

void dijkstra(int n, const vector<pair<int, int>> adj[], int source, int dest) {
    // 1. Initialization
    vector<int> dist(n, INF);
    // Min-Priority Queue: (distance, vertex). 'greater<P>' ensures min-heap.
    priority_queue<P, vector<P>, greater<P>> pq;

    dist[source] = 0;
    pq.push({0, source});

    // 2. Main Algorithm Loop
    while (!pq.empty()) {
        int d = pq.top().first;
        int u = pq.top().second;
        pq.pop();

        // If a shorter path to u was found and processed earlier, skip this outdated entry
        if (d > dist[u]) {
            continue;
        }

        // Optimization: Stop if we've reached the destination
        if (u == dest) {
            break;
        }

        // Relaxation step for all neighbors
        for (const auto& edge : adj[u]) {
            int v = edge.first;
            int weight = edge.second;

            // Check if going through u provides a shorter path to v
            // Also check for potential overflow (dist[u] != INF)
            if (dist[u] != INF && dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                pq.push({dist[v], v});
            }
        }
    }

    // 3. Output Result
    if (dist[dest] == INF) {
        cout << "\nNode " << dest << " is unreachable from node " << source << ".\n";
    } else {
        cout << "\nShortest distance from node " << source << " to node " << dest << " is: " << dist[dest] << endl;
    }
}

int main() {
    int n, e;
    cout << "Enter number of vertices: ";
    cin >> n;

    cout << "Enter number of edges: ";
    cin >> e;

    // Adjacency list: adj[u] stores list of {v, w}
    // Note: Array size [20] is fixed. For robust code, use vector<vector<P>> adj(n);
    vector<pair<int, int>> adj[20]; 

    cout << "Enter edges (u v w):\n";
    for (int i = 0; i < e; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        // Assuming a directed graph. For undirected, add the reverse edge.
        adj[u].push_back({v, w});
        // For undirected, uncomment the line below:
        // adj[v].push_back({u, w}); 
    }

    int source, dest;
    cout << "\nEnter source node: ";
    cin >> source;
    cout << "Enter destination node: ";
    cin >> dest;

    if (source < 0 || source >= n || dest < 0 || dest >= n) {
        cout << "Invalid source or destination node.\n";
        return 1;
    }

    dijkstra(n, adj, source, dest);

    return 0;
}


##Sample Output :
Enter number of vertices: 5
Enter number of edges: 6
Enter edges (u v w):
0 1 10
0 3 5
1 2 1
1 3 2
2 4 4
3 1 3

Enter source node: 0
Enter destination node: 4

Shortest distance from node 0 to node 4 is: 8