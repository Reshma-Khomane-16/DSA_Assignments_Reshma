# Assignment — Smart College Placement Portal Using Advanced Hashing Techniques (Student Generated)

## Title
Design and implement a Smart College Placement Portal using advanced hashing techniques for efficient management of student placement records.

## Objective
To design and implement a placement portal that stores, retrieves, updates and deletes student placement records using advanced hashing techniques (double hashing + dynamic resizing) to maintain high performance and low collision probability even under dynamic data growth.

## Theory
A **placement portal** stores student records (roll number, name, branch, CGPA, placement status, company). Efficient operations (insert/search/delete/update) are essential at scale.

### Advanced hashing techniques used
- **Double Hashing (Open Addressing)**: uses two hash functions `h1` and `h2`. Probe sequence: `h(i) = (h1(key) + i * h2(key)) % size`. Secondary hash reduces clustering compared to linear probing.
- **Dynamic Resizing (Rehashing)**: when load factor exceeds a threshold (e.g., 0.6), the table size grows (next prime) and all records are reinserted to reduce collisions.
- **Tombstone handling**: deleted slots are marked to preserve probe sequences.
- **Prime table sizes**: choosing prime sizes for the table and `h2` modulus reduces cycles and improves distribution.

## Design
- **Key**: integer `roll` (unique)
- **Value**: record `{roll, name, branch, cgpa, status, company}`
- **Hash Table**: open addressing using double hashing with states for slots: `EMPTY`, `OCCUPIED`, `DELETED`.
- **Operations**:
  - `insert(record)` — inserts or updates existing by roll
  - `search(roll)` — returns record if present
  - `delete(roll)` — marks slot deleted (tombstone)
  - `update(roll, ...)` — updates fields
  - `display()` — lists active records
- **Resizing**: triggers when `load_factor = active_count / table_size` > 0.6. New size = next_prime(2 * current_size). Reinsert all `OCCUPIED` entries.

## Algorithm (high level)
1. For `insert(record)`:
   - If `search(roll)` finds existing index → update the record
   - Else compute `h1 = roll % size`, `h2 = 1 + (roll % (size - 1))`
   - Probe `idx = (h1 + i * h2) % size` for `i = 0..size-1` until `EMPTY` or `DELETED` slot found
   - Insert record, increment counts, check load factor → rehash if needed
2. For `search(roll)`:
   - Compute `h1`, `h2`, probe similarly; stop on `EMPTY` (not found) or `OCCUPIED` match
3. For `delete(roll)`:
   - `search(roll)` to locate; if found mark `DELETED` and decrement active count
4. Rehashing:
   - Compute new prime size (approx 2x)
   - Create new table and reinsert all `OCCUPIED` entries

## Implementation (C++)
```cpp
#include <iostream>
#include <cmath>
#include <string>
using namespace std;

struct Student_rdk {
    int id;
    string name;
    string branch;
    string company;
    double package;
    bool placed;
    bool deleted; // flag for deletion
};

const int SIZE_rdk = 20; // hash table size
Student_rdk hashTable_rdk[SIZE_rdk];

// Mid-square hash function
int midSquareHash_rdk(int key_rdk) {
    int square_rdk = key_rdk * key_rdk;
    int digits_rdk = log10(square_rdk) + 1;
    int mid_rdk;
    if (digits_rdk <= 2) {
        mid_rdk = square_rdk % SIZE_rdk;
    } else {
        int shift_rdk = digits_rdk / 2;
        mid_rdk = (square_rdk / (int)pow(10, shift_rdk - 1)) % 100;
        mid_rdk = mid_rdk % SIZE_rdk;
    }
    return mid_rdk;
}

// Insert placement record
void insertStudent_rdk() {
    Student_rdk s_rdk;
    cout << "Enter Student ID: ";
    cin >> s_rdk.id;
    cin.ignore();
    cout << "Enter Name: ";
    getline(cin, s_rdk.name);
    cout << "Enter Branch: ";
    getline(cin, s_rdk.branch);
    cout << "Enter Company (if placed, else leave blank): ";
    getline(cin, s_rdk.company);
    s_rdk.placed = (!s_rdk.company.empty());
    if (s_rdk.placed) {
        cout << "Enter Package: ";
        cin >> s_rdk.package;
        cin.ignore();
    } else {
        s_rdk.package = 0;
    }
    s_rdk.deleted = false;

    int index_rdk = midSquareHash_rdk(s_rdk.id);
    int original_rdk = index_rdk;

    while (hashTable_rdk[index_rdk].id != 0 && !hashTable_rdk[index_rdk].deleted) {
        index_rdk = (index_rdk + 1) % SIZE_rdk;
        if (index_rdk == original_rdk) {
            cout << "Hash table full!\n";
            return;
        }
    }

    hashTable_rdk[index_rdk] = s_rdk;
    cout << "Student inserted at index " << index_rdk << "\n";
}

// Search placement record
void searchStudent_rdk() {
    int id_rdk;
    cout << "Enter Student ID to search: ";
    cin >> id_rdk;

    int index_rdk = midSquareHash_rdk(id_rdk);
    int original_rdk = index_rdk;

    while (hashTable_rdk[index_rdk].id != 0) {
        if (!hashTable_rdk[index_rdk].deleted && hashTable_rdk[index_rdk].id == id_rdk) {
            cout << "\nStudent found:\n";
            cout << "ID: " << hashTable_rdk[index_rdk].id << "\n";
            cout << "Name: " << hashTable_rdk[index_rdk].name << "\n";
            cout << "Branch: " << hashTable_rdk[index_rdk].branch << "\n";
            cout << "Company: " << hashTable_rdk[index_rdk].company << "\n";
            cout << "Package: " << hashTable_rdk[index_rdk].package << "\n";
            cout << "Placed: " << (hashTable_rdk[index_rdk].placed ? "Yes" : "No") << "\n";
            return;
        }
        index_rdk = (index_rdk + 1) % SIZE_rdk;
        if (index_rdk == original_rdk) break;
    }

    cout << "Student not found!\n";
}

// Delete student record
void deleteStudent_rdk() {
    int id_rdk;
    cout << "Enter Student ID to delete: ";
    cin >> id_rdk;

    int index_rdk = midSquareHash_rdk(id_rdk);
    int original_rdk = index_rdk;

    while (hashTable_rdk[index_rdk].id != 0) {
        if (!hashTable_rdk[index_rdk].deleted && hashTable_rdk[index_rdk].id == id_rdk) {
            hashTable_rdk[index_rdk].deleted = true;
            cout << "Student record deleted from index " << index_rdk << "\n";
            return;
        }
        index_rdk = (index_rdk + 1) % SIZE_rdk;
        if (index_rdk == original_rdk) break;
    }

    cout << "Student not found!\n";
}

// Display all placement records
void displayTable_rdk() {
    cout << "\n--- Placement Records ---\n";
    for (int i = 0; i < SIZE_rdk; i++) {
        cout << i << ": ";
        if (hashTable_rdk[i].id != 0 && !hashTable_rdk[i].deleted) {
            cout << hashTable_rdk[i].id << " - " << hashTable_rdk[i].name 
                 << " - " << hashTable_rdk[i].branch
                 << " - " << hashTable_rdk[i].company 
                 << " - " << hashTable_rdk[i].package 
                 << " - " << (hashTable_rdk[i].placed ? "Placed" : "Not Placed");
        }
        cout << "\n";
    }
}

int main() {
    int choice_rdk;
    do {
        cout << "\n--- Smart Placement Portal Menu ---\n";
        cout << "1. Insert Student Record\n";
        cout << "2. Search Student Record\n";
        cout << "3. Delete Student Record\n";
        cout << "4. Display All Records\n";
        cout << "5. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice_rdk;

        switch (choice_rdk) {
            case 1: insertStudent_rdk(); break;
            case 2: searchStudent_rdk(); break;
            case 3: deleteStudent_rdk(); break;
            case 4: displayTable_rdk(); break;
            case 5: cout << "Exiting...\n"; break;
            default: cout << "Invalid choice!\n";
        }
    } while (choice_rdk != 5);

    return 0;
}

```

## Sample Output
```
Enter choice: 1
Enter roll: 101
Enter name: Alice
Enter branch: CSE
Enter cgpa: 8.7
Enter status (Placed/Not Placed): Not Placed
Enter company (or NA): NA
Inserted...

Enter choice: 1
Enter roll: 102
Enter name: Bob
Enter branch: ECE
Enter cgpa: 9.0
Enter status (Placed/Not Placed): Placed
Enter company (or NA): Infosys
Inserted...

Enter choice: 4
Capacity: 23, Active: 2
0: <empty>
1: <empty>
2: [101, Alice, CSE, 8.7, Not Placed, NA]
3: <empty>
...

Enter choice: 2
Enter roll to search: 102
Found: 102, Bob, ECE, 9.0, Placed, Infosys
```

---
File saved as **smart_college_placement_portal.md** in the working directory.
