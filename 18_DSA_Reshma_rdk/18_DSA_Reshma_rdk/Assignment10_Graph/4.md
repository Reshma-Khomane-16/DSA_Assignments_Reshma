## input

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Edge {
public:
    int src_rdk, dest_rdk, wt_rdk;
};

class Graph {
    int nodes_rdk;
    vector<vector<pair<int,int>>> adjList_rdk;  
    vector<Edge> edges_rdk;

public:
    Graph(int n_rdk) {
        nodes_rdk = n_rdk;
        adjList_rdk.resize(nodes_rdk);
    }

    void acceptGraph_rdk() {
        int edgesCount_rdk;
        cout << "\nEnter number of edges: ";
        cin >> edgesCount_rdk;

        cout << "Enter edges (src dest weight):\n";
        for (int i = 0; i < edgesCount_rdk; i++) {
            int u_rdk, v_rdk, w_rdk;
            cin >> u_rdk >> v_rdk >> w_rdk;

            adjList_rdk[u_rdk].push_back({v_rdk, w_rdk});
            adjList_rdk[v_rdk].push_back({u_rdk, w_rdk}); // undirected

            Edge e;
            e.src_rdk = u_rdk;
            e.dest_rdk = v_rdk;
            e.wt_rdk = w_rdk;

            edges_rdk.push_back(e);
        }

        cout << "\nGraph accepted successfully!\n";
    }

    static bool cmp_rdk(Edge a, Edge b) {
        return a.wt_rdk < b.wt_rdk;
    }

    int findParent_rdk(int node_rdk, vector<int> &parent_rdk) {
        if (parent_rdk[node_rdk] == node_rdk)
            return node_rdk;
        return parent_rdk[node_rdk] = findParent_rdk(parent_rdk[node_rdk], parent_rdk);
    }

    void unionSet_rdk(int u_rdk, int v_rdk, vector<int> &parent_rdk, vector<int> &rank_rdk) {
        u_rdk = findParent_rdk(u_rdk, parent_rdk);
        v_rdk = findParent_rdk(v_rdk, parent_rdk);

        if (rank_rdk[u_rdk] < rank_rdk[v_rdk])
            parent_rdk[u_rdk] = v_rdk;
        else if (rank_rdk[u_rdk] > rank_rdk[v_rdk])
            parent_rdk[v_rdk] = u_rdk;
        else {
            parent_rdk[v_rdk] = u_rdk;
            rank_rdk[u_rdk]++;
        }
    }

    void kruskal_rdk() {
        cout << "\n--- Minimum Spanning Tree (Kruskal) ---\n";

        sort(edges_rdk.begin(), edges_rdk.end(), cmp_rdk);

        vector<int> parent_rdk(nodes_rdk);
        vector<int> rank_rdk(nodes_rdk, 0);

        for (int i = 0; i < nodes_rdk; i++)
            parent_rdk[i] = i;

        vector<Edge> mst_rdk;
        int totalWeight_rdk = 0;

        for (auto &edge_rdk : edges_rdk) {
            int u_rdk = findParent_rdk(edge_rdk.src_rdk, parent_rdk);
            int v_rdk = findParent_rdk(edge_rdk.dest_rdk, parent_rdk);

            if (u_rdk != v_rdk) {
                mst_rdk.push_back(edge_rdk);
                totalWeight_rdk += edge_rdk.wt_rdk;
                unionSet_rdk(u_rdk, v_rdk, parent_rdk, rank_rdk);
            }
        }

        cout << "\nEdges in MST:\n";
        for (auto &e : mst_rdk)
            cout << e.src_rdk << " -- " << e.dest_rdk << " (Weight: " << e.wt_rdk << ")\n";

        cout << "\nTotal Weight of MST = " << totalWeight_rdk << "\n";
    }
};

int main() {
    int nodes_rdk, choice_rdk;

    cout << "Enter number of nodes: ";
    cin >> nodes_rdk;

    Graph g_rdk(nodes_rdk);

    while (true) {
        cout << "\n------ MENU ------\n";
        cout << "1. Accept Graph (Adjacency List)\n";
        cout << "2. Run Kruskalâ€™s Algorithm\n";
        cout << "3. Exit\n";
        cout << "Enter choice: ";
        cin >> choice_rdk;

        switch (choice_rdk) {
            case 1:
                g_rdk.acceptGraph_rdk();
                break;

            case 2:
                g_rdk.kruskal_rdk();
                break;

            case 3:
                cout << "Exiting...\n";
                return 0;

            default:
                cout << "Invalid choice! Try again.\n";
        }
    }
}
