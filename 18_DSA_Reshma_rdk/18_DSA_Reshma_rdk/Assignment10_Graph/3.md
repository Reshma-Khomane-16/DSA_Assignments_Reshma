## krushkal

#include <iostream>
#include <vector>
#include <climits>
#include <queue>

using namespace std;

class Graph {
    int nodes_rdk;
    vector<vector<pair<int,int>>> adjList_rdk;  
    // pair = (neighbor, weight)

public:
    Graph(int n_rdk) {
        nodes_rdk = n_rdk;
        adjList_rdk.resize(nodes_rdk);
    }

    void acceptGraph_rdk() {
        int edges_rdk;
        cout << "\nEnter number of edges: ";
        cin >> edges_rdk;

        cout << "Enter edges (src dest weight):\n";
        for (int i = 0; i < edges_rdk; i++) {
            int u_rdk, v_rdk, w_rdk;
            cin >> u_rdk >> v_rdk >> w_rdk;

            adjList_rdk[u_rdk].push_back({v_rdk, w_rdk});
            adjList_rdk[v_rdk].push_back({u_rdk, w_rdk}); // undirected graph
        }

        cout << "\nGraph accepted successfully!\n";
    }

    void prim_rdk(int start_rdk) {
        vector<int> key_rdk(nodes_rdk, INT_MAX);
        vector<bool> inMST_rdk(nodes_rdk, false);
        vector<int> parent_rdk(nodes_rdk, -1);

        key_rdk[start_rdk] = 0;

        for (int i = 0; i < nodes_rdk - 1; i++) {
            int minKey_rdk = INT_MAX, u_rdk = -1;

            for (int j = 0; j < nodes_rdk; j++) {
                if (!inMST_rdk[j] && key_rdk[j] < minKey_rdk) {
                    minKey_rdk = key_rdk[j];
                    u_rdk = j;
                }
            }

            inMST_rdk[u_rdk] = true;

            for (auto &edge_rdk : adjList_rdk[u_rdk]) {
                int v_rdk = edge_rdk.first;
                int weight_rdk = edge_rdk.second;

                if (!inMST_rdk[v_rdk] && weight_rdk < key_rdk[v_rdk]) {
                    parent_rdk[v_rdk] = u_rdk;
                    key_rdk[v_rdk] = weight_rdk;
                }
            }
        }

        cout << "\n--- Minimum Spanning Tree (Prim) ---\n";
        int totalWeight_rdk = 0;

        for (int i = 0; i < nodes_rdk; i++) {
            if (parent_rdk[i] != -1) {
                cout << parent_rdk[i] << " -- " << i 
                     << " (Weight: " << key_rdk[i] << ")\n";
                totalWeight_rdk += key_rdk[i];
            }
        }

        cout << "\nTotal Weight of MST = " << totalWeight_rdk << "\n";
    }
};

int main() {
    int nodes_rdk, choice_rdk, start_rdk;

    cout << "Enter number of nodes: ";
    cin >> nodes_rdk;

    Graph g_rdk(nodes_rdk);

    while (true) {
        cout << "\n------ MENU ------\n";
        cout << "1. Accept Graph (Adjacency List)\n";
        cout << "2. Run Primâ€™s Algorithm\n";
        cout << "3. Exit\n";
        cout << "Enter choice: ";
        cin >> choice_rdk;

        switch (choice_rdk) {
            case 1:
                g_rdk.acceptGraph_rdk();
                break;

            case 2:
                cout << "Enter starting node: ";
                cin >> start_rdk;
                g_rdk.prim_rdk(start_rdk);
                break;

            case 3:
                cout << "Exiting...\n";
                return 0;

            default:
                cout << "Invalid choice! Try again.\n";
        }
    }
}
